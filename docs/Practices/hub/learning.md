# Useful Abstractions Learning
The following are simply links to [useful abstractions](../../glossary.md#useful-abstraction) (UAs) that may or may not be references by the [guidelines](./hub.md#guidelines) for Hub. These are **intended as reference material to facilitate understanding and are not a canonical list of UAs we implement** in full or part within Hub or elsewhere.

## Coupling and Cohesion
**This may be the most important concept to understand. The holy grail in software design and architecture is high cohesion and low coupling. This is easier said than done.**
- [Coupling and Cohesion Short](https://www.youtube.com/shorts/K_Z9FJ7jdFo) *1 min watch*
- [Highly COHESIVE Software Design to tame Complexity](https://www.youtube.com/watch?v=r0-GC3Y_OME) *9 min watch*
  - *[In large systems, the idea of having a single entity live in a single table just isn't reality](https://youtu.be/r0-GC3Y_OME?t=128). This quote and the example he gives can be applied to many entities within Prenda software: [Micro]school, term, guide, etc.*
- [Low Coupling, High Cohesion](https://medium.com/clarityhub/low-coupling-high-cohesion-3610e35ac4a6) *3 min read*
- [AVOID Entity Services by Focusing on Capabilities (snippet)](https://youtu.be/2gOOstEI4vU?t=383) *2 min watch - watch from linked timestamp*
- [SOLID Principles? Nope, just Coupling and Cohesion](https://www.youtube.com/watch?v=YDNR_gfBk0Q&ab_channel=CodeOpinion) *14 min watch*
  - *[In my experience, informational cohesion can really drive a large degree of coupling.](https://youtu.be/YDNR_gfBk0Q?t=228)*. *Informational Cohesion has it's place. But the switch from thinking with a focus on Informational Cohesion to a focus on Function Cohesion aligns you closer with business concerns and frees you from the mental gymnastics required managing coupling and cohesion while aligning new features and support of old features against an information focused system - data supports capabilities, not the other way around.*

## Validatation

## Vertical Slices

## Bounded Contexts

## Domain Modeling
- [Errors as Documentation](https://aldesantis.medium.com/fail-better-turning-software-errors-into-documentation-764a6bb7d71f)

## Clean/Hexagonal/Onion Architecture

## Ports and Adapters

## More than CRUD

## Slim Apis are Easier to Maintain 

## Testing

## Make Invalid States Impossible

## Persistence Agnosticism

## Eventual Consistency

## Repository Pattern

## Functional vs Object Oriented vs Procedural

## Derived Types

### [Synchronized Derived Types](https://javascript.plainenglish.io/typescript-how-to-create-synchronized-derived-types-4bf2371a9eab) *5 min read*

## Imperative vs Declarative

## Command Query Separation

## Errors as Values


# Additional Learning
