"use strict";(self.webpackChunkprenda_engineering=self.webpackChunkprenda_engineering||[]).push([[7721],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,y=p["".concat(l,".").concat(m)]||p[m]||u[m]||i;return n?r.createElement(y,o(o({ref:t},d),{},{components:n})):r.createElement(y,o({ref:t},d))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},739:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={},o="Examples",s={unversionedId:"Practices/hub/examples",id:"Practices/hub/examples",title:"Examples",description:"Hub Directory Structure",source:"@site/docs/Practices/hub/examples.md",sourceDirName:"Practices/hub",slug:"/Practices/hub/examples",permalink:"/docs/Practices/hub/examples",draft:!1,editUrl:"https://github.com/prenda-school/prenda-school.github.io/tree/main/docs/Practices/hub/examples.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Working with Bounded Contexts in Hub",permalink:"/docs/Practices/hub/"},next:{title:"Useful Abstractions",permalink:"/docs/Practices/hub/learning"}},l={},c=[{value:"Hub Directory Structure",id:"hub-directory-structure",level:2},{value:"Endeavour to make invalid states impossible",id:"endeavour-to-make-invalid-states-impossible",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"examples"},"Examples"),(0,a.kt)("h2",{id:"hub-directory-structure"},"Hub Directory Structure"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// WIP\nbounded-contexts\n  some-bc-1\n    domain            // base domain code for some-bc-1\n    data              // integration code for external resources\n    dependent-bcs     // integration code for other bounded contexts\n    legacy-handlers   // old code not following new architecture\n    repository        // shared database code for all slices\n      crud-fns        // functions that mutate data a single entity w/o condition or search by a unique id w/o filtering\n        find-entity1-by-id.ts\n        insert-entity2.ts\n      entity1.ts      // types representing database tables required for entity1\n      entity2.ts      // types representing database tables required for entity2\n    commands\n      some-command-1\n        index.ts      // An index.ts file with API, command, domain, and repository regions\n      some-command-2\n        api.ts\n        command.ts\n        domain.ts\n        repository.ts\n      some-command-3\n        handlers\n          request.ts\n          event.ts\n        command.ts\n        domain.ts\n        repository.ts\n    queries\n      some-query-1\n        index.ts      // An index.ts file with API, query, domain, and repository regions\n      some-query-2\n        api.ts\n        domain.ts\n        query.ts\n        repository.ts\n    routes            // Routes go in this dir, not much guidelines past this. Reference routing point in [the future](hub.md#the-future) for possible iterations\n      router1.ts\n      router2.ts\n  some-bc-2\n")),(0,a.kt)("h2",{id:"endeavour-to-make-invalid-states-impossible"},"Endeavour to make invalid states impossible"),(0,a.kt)("h3",{id:"example-1"},"Example 1"),(0,a.kt)("p",null,"If performing operations that utilize an email address which must be validated, consider creating a branded type rather than utilizing a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),". This way it becomes very clear which functions within your application need a validated email and which ones don't care."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// Original\nconst sendEmail = (emailAddress: string) => {/* stuff */}\n\n// With Branded Type\ntype ValidatedEmail = { \n  _tag: "ValidatedEmail"; \n  value: string \n}\nconst sendEmail = (emailAddress: ValidatedEmail) => {/* stuff */}\n')),(0,a.kt)("h3",{id:"example-2"},"Example 2"),(0,a.kt)("p",null,"Sometimes you need to represent a single concept which can take on different shapes based on its kind. It can be tempting to tack on all the fields that might be required for all the kinds on a single type. Here are a few of the many problems you can face by doing this:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The type can become bloated"),(0,a.kt)("li",{parentName:"ul"},"You end up optionalizing all the fields that aren't common among the kinds"),(0,a.kt)("li",{parentName:"ul"},"You potentially may end up operating on an object which is invalid due to conflicting fields from different kinds")),(0,a.kt)("p",null,"To resolve this, extract out the common fields to one type, create a different type for each of the kinds, then utilize the compositional to create a shape which does not allow for an invalid representation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// Original Version 1\ntype School = { \n  name: string; \n  \n  // Family Data\n  familyField1?: string\n  familyField2?: boolean\n  \n  // Partner Data\n  partnerField1?: string\n  partnerField2?: number\n}\n\n// Original Version 2\ntype School = {\n  name: string;\n  type: "family" | "partner"\n  \n  // Family Data\n  familyField1?: string\n  familyField2?: boolean\n  \n  // Partner Data\n  partnerField1?: string\n  partnerField2?: number\n}\n\n// With Union\ntype SchoolBase = {\n  name: string\n}\ntype FamilySchool = { \n  _tag: "FamilySchool"; \n  familyField1: string\n  familyField2: boolean\n}; \ntype PartnerSchool = { \n  _tag: "PartnerSchool"; \n  partnerField1: string\n  partnerField2: number\n}\ntype School = SchoolBase & (FamilySchool | PartnerSchool); \n')))}u.isMDXComponent=!0}}]);